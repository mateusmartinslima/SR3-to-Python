\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}

\geometry{margin=2.5cm}

\title{Guide to the CMG IMEX \texttt{.sr3} File and Data Access}
\author{Mateus Lima}
\date{\today}

\lstset{
  language=Python,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{green!50!black},
  stringstyle=\color{red},
  breaklines=true,
  showstringspaces=false
}

\begin{document}

\maketitle

\section{Introduction}

The \texttt{.sr3} file generated by CMG IMEX contains the simulation results for both wells and grid cells, including pressures, saturations, formation volume factors, viscosities, and fluxes. The file is stored in an HDF5 hierarchical format, which allows direct access using Python's \texttt{h5py} library.

This guide explains the file structure, how to access well and grid data, and provides a general Python routine to extract all relevant information into a single DataFrame for post-processing.

\section{File Structure}

When opening an \texttt{.sr3} file with \texttt{h5py}:

\begin{lstlisting}[language=Python]
import h5py
f = h5py.File("TP1D.sr3", "r")
print(f.keys())
\end{lstlisting}

Typical output:

\begin{itemize}
    \item \texttt{General}: general simulation information (history tables, units, etc.)
    \item \texttt{SpatialProperties}: cell-level results for each timestep
    \item \texttt{Tables}: optional auxiliary tables
    \item \texttt{TimeSeries}: well-level time series data
\end{itemize}

\subsection{TimeSeries / WELLS}

The group \texttt{TimeSeries/WELLS} contains the well results:

\begin{itemize}
    \item \texttt{Origins}: well names
    \item \texttt{Variables}: monitored variables (BHP, WHP, flow rates, BO, etc.)
    \item \texttt{Data}: numerical values stored in shape \texttt{(timesteps, n\_variables, n\_wells)}
    \item \texttt{Timesteps}: array of simulation timesteps
\end{itemize}

Example to read well data:

\begin{lstlisting}[language=Python]
wells = [w.decode() for w in f['TimeSeries/WELLS/Origins'][:]]
variables = [v.decode() for v in f['TimeSeries/WELLS/Variables'][:]]
data = f['TimeSeries/WELLS/Data'][:]  # shape: (timesteps, n_variables, n_wells)
\end{lstlisting}

\subsection{SpatialProperties / Grid}

The group \texttt{SpatialProperties} contains the results for each grid cell:

\begin{itemize}
    \item Each timestep is stored as a numeric subgroup (\texttt{000000}, \texttt{000001}, etc.)
    \item Within each timestep, datasets may include:
    \begin{itemize}
        \item \texttt{PRES}: pressure in each cell
        \item \texttt{SO}, \texttt{SW}: saturations
        \item \texttt{BO}: formation volume factors
        \item \texttt{VISO}, \texttt{VISW}: viscosities
    \end{itemize}
\end{itemize}

Example to read pressures for all grid cells:

\begin{lstlisting}[language=Python]
df_list = []
for timestep_name in f['SpatialProperties'].keys():
    if timestep_name == 'Statistics':
        continue
    pres = f[f'SpatialProperties/{timestep_name}/PRES'][:]
    n_cells = pres.shape[0]
    df_tmp = pd.DataFrame({
        'Timestep': int(timestep_name),
        'Cell': np.arange(n_cells),
        'Pressure': pres
    })
    df_list.append(df_tmp)

df_pres = pd.concat(df_list, ignore_index=True)
\end{lstlisting}

\section{General Python Code to Extract All Data into a Single DataFrame}

The following Python snippet collects **all well and grid data** into one DataFrame for analysis:

\begin{lstlisting}[language=Python]
import h5py
import pandas as pd
import numpy as np

f = h5py.File("TP1D.sr3", "r")

# ---- Well Data ----
wells = [w.decode() if isinstance(w, bytes) else str(w) for w in f['TimeSeries/WELLS/Origins'][:]]
variables = [v.decode() if isinstance(v, bytes) else str(v) for v in f['TimeSeries/WELLS/Variables'][:]]
data = f['TimeSeries/WELLS/Data'][:]  # shape: (timesteps, n_variables, n_wells)
timesteps = data.shape[0]

well_list = []
for t in range(timesteps):
    for v_idx, var_name in enumerate(variables):
        for w_idx, well_name in enumerate(wells):
            well_list.append({
                'Timestep': t,
                'Well': well_name,
                'Variable': var_name,
                'Value': data[t, v_idx, w_idx]
            })
df_wells = pd.DataFrame(well_list)


# ---- Grid Data ----
grid_list = []
for timestep_name in f['SpatialProperties'].keys():
    if timestep_name == 'Statistics':
        continue
    timestep_idx = int(timestep_name)
    for var_name in ['PRES','BO','SO','SW']:  # add other variables if needed
        if var_name in f[f'SpatialProperties/{timestep_name}']:
            values = f[f'SpatialProperties/{timestep_name}/{var_name}'][:]
            n_cells = values.shape[0]
            df_tmp = pd.DataFrame({
                'Timestep': timestep_idx,
                'Cell': np.arange(n_cells),
                'Variable': var_name,
                'Value': values
            })
            grid_list.append(df_tmp)
df_grid = pd.concat(grid_list, ignore_index=True)

# Combine wells and grid data if desired
df_all = pd.concat([df_wells, df_grid], ignore_index=True)
\end{lstlisting}

This produces a single DataFrame \texttt{df\_all} containing **all well and grid variables for all timesteps**, ready for analysis.

\end{document}
